#include "lpc177x_8x_adc.h"
#include "lpc177x_8x_pinsel.h"
#include "lpc177x_8x_gpdma.h"
#include "lpc177x_8x_gpio.h"
#include "lpc177x_8x_mci.h"
#include "touchpanel.h"
#include <rtgui/rtgui.h>
#include <rtgui/driver.h>
#include <rtgui/rtgui_server.h>
#include <rtgui/event.h>
#include <rtthread.h>

//ADC input preset on this board		LPC
#define TENGHUA_ADC_PREPARED_XM_CHANNEL		(ADC_CHANNEL_0)
#define TENGHUA_ADC_PREPARED_XM_INTR			(ADC_ADINTEN0)

#define TENGHUA_ADC_PREPARED_XP_CHANNEL		(ADC_CHANNEL_1)
#define TENGHUA_ADC_PREPARED_XP_INTR			(ADC_ADINTEN1)

#define TENGHUA_ADC_PREPARED_YM_CHANNEL		(ADC_CHANNEL_5)
#define TENGHUA_ADC_PREPARED_YM_INTR			(ADC_ADINTEN5)

#define TENGHUA_ADC_PREPARED_YP_CHANNEL		(ADC_CHANNEL_6)
#define TENGHUA_ADC_PREPARED_YP_INTR			(ADC_ADINTEN6)

#define TENGHUA_ADC_PREPARED_CHXM_PORT		(0)
#define TENGHUA_ADC_PREPARED_CHXM_PIN			(23)
#define TENGHUA_ADC_PREPARED_CHXM_FUNC_NO		(1)
#define TENGHUA_ADC_PREPARED_CHXMIO_FUNC_NO		(0)
#define TENGHUA_XM_MASK		(1 << TENGHUA_ADC_PREPARED_CHXM_PIN)

#define TENGHUA_ADC_PREPARED_CHXP_PORT		(0)
#define TENGHUA_ADC_PREPARED_CHXP_PIN			(24)
#define TENGHUA_ADC_PREPARED_CHXP_FUNC_NO		(1)
#define TENGHUA_ADC_PREPARED_CHXPIO_FUNC_NO		(0)
#define TENGHUA_XP_MASK		(1 << TENGHUA_ADC_PREPARED_CHXP_PIN)

#define TENGHUA_ADC_PREPARED_CHYM_PORT		(1)
#define TENGHUA_ADC_PREPARED_CHYM_PIN			(31)
#define TENGHUA_ADC_PREPARED_CHYM_FUNC_NO		(3)
#define TENGHUA_ADC_PREPARED_CHYMIO_FUNC_NO		(0)
#define TENGHUA_YM_MASK		(1 << TENGHUA_ADC_PREPARED_CHYM_PIN)

#define TENGHUA_ADC_PREPARED_CHYP_PORT		(0)
#define TENGHUA_ADC_PREPARED_CHYP_PIN			(12)
#define TENGHUA_ADC_PREPARED_CHYP_FUNC_NO		(3)	
#define TENGHUA_ADC_PREPARED_CHYPIO_FUNC_NO		(0)
#define TENGHUA_YP_MASK		(1 << TENGHUA_ADC_PREPARED_CHYP_PIN)

/* Terminal Counter flag for Channel 0 */
__IO uint32_t Channel_TP_TC;

/* Error Counter flag for Channel 0 */
__IO uint32_t Channel_TP_Err;
static uint32_t adc_value =0;
static GPDMA_Channel_CFG_Type GPDMACfg;
/** DMA size of transfer */
#define DMA_SIZE		1


int has_touched(void)
{
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_ADC_PREPARED_CHXP_PIN, TENGHUA_ADC_PREPARED_CHXPIO_FUNC_NO);
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_ADC_PREPARED_CHXM_PIN, TENGHUA_ADC_PREPARED_CHXMIO_FUNC_NO);
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_ADC_PREPARED_CHYM_PIN, TENGHUA_ADC_PREPARED_CHYMIO_FUNC_NO);
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_ADC_PREPARED_CHYP_PIN, TENGHUA_ADC_PREPARED_CHYPIO_FUNC_NO);
	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_XP_MASK, GPIO_DIRECTION_OUTPUT);
	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_XM_MASK, GPIO_DIRECTION_OUTPUT);
	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_YM_MASK, GPIO_DIRECTION_INPUT);	
	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_YP_MASK, GPIO_DIRECTION_INPUT);	
	PINSEL_SetPinMode(TENGHUA_ADC_PREPARED_CHYM_PORT,TENGHUA_ADC_PREPARED_CHYM_PIN,IOCON_MODE_PULLUP);
	PINSEL_SetPinMode(TENGHUA_ADC_PREPARED_CHYP_PORT,TENGHUA_ADC_PREPARED_CHYP_PIN,IOCON_MODE_PULLUP);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYP_PORT,TENGHUA_ADC_PREPARED_CHYP_PIN,DISABLE);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYM_PORT,TENGHUA_ADC_PREPARED_CHYM_PIN,DISABLE);
	PINSEL_SetOpenDrainMode(TENGHUA_ADC_PREPARED_CHXP_PORT,TENGHUA_ADC_PREPARED_CHXP_PIN,DISABLE); 
	PINSEL_SetOpenDrainMode(TENGHUA_ADC_PREPARED_CHXM_PORT,TENGHUA_ADC_PREPARED_CHXM_PIN,DISABLE); 
	
	GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_XP_MASK, 0);
	GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_XM_MASK, 0);
	{
		uint32_t ymvalue = GPIO_ReadValue( TENGHUA_ADC_PREPARED_CHYM_PORT);
		uint32_t ypvalue = GPIO_ReadValue( TENGHUA_ADC_PREPARED_CHYP_PORT);
	/*	uint32_t ymfvalue = FIO_ReadValue( TENGHUA_ADC_PREPARED_CHYM_PORT);
		uint32_t ypfvalue = FIO_ReadValue( TENGHUA_ADC_PREPARED_CHYP_PORT);	 
		rt_kprintf("ym %08x yp %08x ",
					ymvalue&TENGHUA_YM_MASK,
					ypvalue&TENGHUA_YP_MASK);		 */

		if((ymvalue & TENGHUA_YM_MASK)==0)
			return 1;
	}
 	return 0;
}


void get_x_y(int * x ,int * y)
{	   
 
	Channel_TP_TC = 0;

	ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_YM_INTR, DISABLE);			
	ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_XM_INTR, DISABLE);
#if 0
	GPIO_ClearValue(TENGHUA_ADC_PREPARED_CHXM_PORT,	 TENGHUA_ADC_PREPARED_CHXM_PIN);
	GPIO_ClearValue(TENGHUA_ADC_PREPARED_CHXP_PORT,	 TENGHUA_ADC_PREPARED_CHXP_PIN);  
	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_XM_MASK, GPIO_DIRECTION_INPUT);
   	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_XP_MASK, GPIO_DIRECTION_INPUT);

	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_ADC_PREPARED_CHXM_PIN, TENGHUA_ADC_PREPARED_CHXM_FUNC_NO);
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_ADC_PREPARED_CHXP_PIN, TENGHUA_ADC_PREPARED_CHXP_FUNC_NO); 
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHXM_PORT,TENGHUA_ADC_PREPARED_CHXM_PIN,ENABLE);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHXP_PORT,TENGHUA_ADC_PREPARED_CHXP_PIN,ENABLE);
	
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_ADC_PREPARED_CHYM_PIN, TENGHUA_ADC_PREPARED_CHYMIO_FUNC_NO);
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_ADC_PREPARED_CHYP_PIN, TENGHUA_ADC_PREPARED_CHYPIO_FUNC_NO);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYM_PORT,TENGHUA_ADC_PREPARED_CHYM_PIN,DISABLE);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYP_PORT,TENGHUA_ADC_PREPARED_CHYP_PIN,DISABLE);
	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_YM_MASK, GPIO_DIRECTION_OUTPUT);
   	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_YP_MASK, GPIO_DIRECTION_OUTPUT);
	GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_YM_MASK, 1);
	GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_YP_MASK, 0);
	/*_DBG("\r\t\t\t\tYM:");
	_DBD16(PIN_GetConf( TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_ADC_PREPARED_CHYM_PIN));
	_DBG("\r\t\t\t\t\t v:");
	_DBD(GPIO_ReadValue(TENGHUA_ADC_PREPARED_CHXM_PORT));
	*/
	ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_XM_INTR, ENABLE);

	ADC_ChannelCmd(LPC_ADC, TENGHUA_ADC_PREPARED_XM_CHANNEL, ENABLE);

	GPDMA_ChannelCmd(DMA_TP_CHANNEL, ENABLE);
	
	ADC_StartCmd(LPC_ADC, ADC_START_NOW);

	/* Wait for GPDMA processing complete */
	while ((Channel_TP_TC == 0))rt_thread_delay(1);

	// Disable GPDMA channel DMA_TP_CHANNEL
	GPDMA_ChannelCmd(DMA_TP_CHANNEL, DISABLE);

	//Display the result of conversion on the UART

	//_DBG(ADC_GlobalGetChn(LPC_ADC)!=0?"\r\t\tY:":"\rX:");
	adc_value = ADC_DR_RESULT(adc_value);
	if(y!=RT_NULL)
		*y=adc_value;
	/* GPDMA Re-setup */
	GPDMA_Setup(&GPDMACfg);
	Channel_TP_TC = 0;
	ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_XM_INTR, DISABLE);
	GPIO_ClearValue(TENGHUA_ADC_PREPARED_CHYM_PORT,	 TENGHUA_ADC_PREPARED_CHYM_PIN);
	GPIO_ClearValue(TENGHUA_ADC_PREPARED_CHYP_PORT,	 TENGHUA_ADC_PREPARED_CHYP_PIN);
	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_YM_MASK, GPIO_DIRECTION_INPUT);
   	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_YP_MASK, GPIO_DIRECTION_INPUT);

	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_ADC_PREPARED_CHYM_PIN, TENGHUA_ADC_PREPARED_CHYM_FUNC_NO);
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_ADC_PREPARED_CHYP_PIN, TENGHUA_ADC_PREPARED_CHYP_FUNC_NO);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYM_PORT,TENGHUA_ADC_PREPARED_CHYM_PIN,ENABLE);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYP_PORT,TENGHUA_ADC_PREPARED_CHYP_PIN,ENABLE);
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_ADC_PREPARED_CHXM_PIN, TENGHUA_ADC_PREPARED_CHXMIO_FUNC_NO);
	PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_ADC_PREPARED_CHXP_PIN, TENGHUA_ADC_PREPARED_CHXPIO_FUNC_NO);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHXM_PORT,TENGHUA_ADC_PREPARED_CHXM_PIN,DISABLE);
	PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHXP_PORT,TENGHUA_ADC_PREPARED_CHXP_PIN,DISABLE);
	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_XM_MASK, GPIO_DIRECTION_OUTPUT);
   	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_XP_MASK, GPIO_DIRECTION_OUTPUT);
	GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_XM_MASK, 1);
	GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_XP_MASK, 0);
	/*_DBG("\r\t\t\t\tXM:");
	_DBD16(PIN_GetConf( TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_ADC_PREPARED_CHXM_PIN));
	_DBG("\r\t\t\t\t\t v:");
	_DBD(GPIO_ReadValue(TENGHUA_ADC_PREPARED_CHXM_PORT));
	*/
	ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_YM_INTR, ENABLE);
	ADC_ChannelCmd(LPC_ADC, TENGHUA_ADC_PREPARED_YM_CHANNEL, ENABLE);
	GPDMA_ChannelCmd(DMA_TP_CHANNEL, ENABLE);
	//ADC_GlobalSetChn(TENGHUA_ADC_PREPARED_XM_CHANNEL);
	ADC_StartCmd(LPC_ADC, ADC_START_NOW);

	/* Wait for GPDMA processing complete */
	while ((Channel_TP_TC == 0))rt_thread_delay(1);

	// Disable GPDMA channel 0
	GPDMA_ChannelCmd(DMA_TP_CHANNEL, DISABLE);

	//Display the result of conversion on the UART

	//_DBG(ADC_GlobalGetChn(LPC_ADC)!=0?"\r\t\tY:":"\rX:");
	adc_value = ADC_DR_RESULT(adc_value);
	if(x!=RT_NULL)
		*x=adc_value;
#else
	while (1)
	{
		static int channel = TENGHUA_ADC_PREPARED_YM_CHANNEL ;
		
		// Wait for a while
		rt_thread_delay(RT_TICK_PER_SECOND/10);
	   	if(!has_touched())
			continue;						 	

		ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_YM_INTR, DISABLE);			
		ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_XM_INTR, DISABLE);			
		// Enable GPDMA channel 0
		switch(channel){
		case TENGHUA_ADC_PREPARED_XM_CHANNEL:  
		case TENGHUA_ADC_PREPARED_XP_CHANNEL:
			GPIO_ClearValue(TENGHUA_ADC_PREPARED_CHXM_PORT,	 TENGHUA_ADC_PREPARED_CHXM_PIN);
			GPIO_ClearValue(TENGHUA_ADC_PREPARED_CHXP_PORT,	 TENGHUA_ADC_PREPARED_CHXP_PIN);  
			GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_XM_MASK, GPIO_DIRECTION_INPUT);
		   	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_XP_MASK, GPIO_DIRECTION_INPUT);

			PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_ADC_PREPARED_CHXM_PIN, TENGHUA_ADC_PREPARED_CHXM_FUNC_NO);
			PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_ADC_PREPARED_CHXP_PIN, TENGHUA_ADC_PREPARED_CHXP_FUNC_NO); 
			PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHXM_PORT,TENGHUA_ADC_PREPARED_CHXM_PIN,ENABLE);
			PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHXP_PORT,TENGHUA_ADC_PREPARED_CHXP_PIN,ENABLE);
			
			PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_ADC_PREPARED_CHYM_PIN, TENGHUA_ADC_PREPARED_CHYMIO_FUNC_NO);
			PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_ADC_PREPARED_CHYP_PIN, TENGHUA_ADC_PREPARED_CHYPIO_FUNC_NO);
			PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYM_PORT,TENGHUA_ADC_PREPARED_CHYM_PIN,DISABLE);
			PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYP_PORT,TENGHUA_ADC_PREPARED_CHYP_PIN,DISABLE);
			GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_YM_MASK, GPIO_DIRECTION_OUTPUT);
		   	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_YP_MASK, GPIO_DIRECTION_OUTPUT);
			GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_YM_MASK, 1);
			GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_YP_MASK, 0);
			/*_DBG("\r\t\t\t\tYM:");
			_DBD16(PIN_GetConf( TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_ADC_PREPARED_CHYM_PIN));
			_DBG("\r\t\t\t\t\t v:");
			_DBD(GPIO_ReadValue(TENGHUA_ADC_PREPARED_CHXM_PORT));
			*/
			ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_XM_INTR, ENABLE);
			
			
			break;
		case TENGHUA_ADC_PREPARED_YM_CHANNEL:
		case TENGHUA_ADC_PREPARED_YP_CHANNEL:
			GPIO_ClearValue(TENGHUA_ADC_PREPARED_CHYM_PORT,	 TENGHUA_ADC_PREPARED_CHYM_PIN);
			GPIO_ClearValue(TENGHUA_ADC_PREPARED_CHYP_PORT,	 TENGHUA_ADC_PREPARED_CHYP_PIN);
			GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_YM_MASK, GPIO_DIRECTION_INPUT);
		   	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_YP_MASK, GPIO_DIRECTION_INPUT);

			PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYM_PORT, TENGHUA_ADC_PREPARED_CHYM_PIN, TENGHUA_ADC_PREPARED_CHYM_FUNC_NO);
			PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHYP_PORT, TENGHUA_ADC_PREPARED_CHYP_PIN, TENGHUA_ADC_PREPARED_CHYP_FUNC_NO);
			PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYM_PORT,TENGHUA_ADC_PREPARED_CHYM_PIN,ENABLE);
			PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHYP_PORT,TENGHUA_ADC_PREPARED_CHYP_PIN,ENABLE);
			PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_ADC_PREPARED_CHXM_PIN, TENGHUA_ADC_PREPARED_CHXMIO_FUNC_NO);
			PINSEL_ConfigPin (TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_ADC_PREPARED_CHXP_PIN, TENGHUA_ADC_PREPARED_CHXPIO_FUNC_NO);
			PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHXM_PORT,TENGHUA_ADC_PREPARED_CHXM_PIN,DISABLE);
			PINSEL_SetAnalogPinMode(TENGHUA_ADC_PREPARED_CHXP_PORT,TENGHUA_ADC_PREPARED_CHXP_PIN,DISABLE);
			GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_XM_MASK, GPIO_DIRECTION_OUTPUT);
		   	GPIO_SetDir(TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_XP_MASK, GPIO_DIRECTION_OUTPUT);
			GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_XM_MASK, 1);
			GPIO_OutputValue(TENGHUA_ADC_PREPARED_CHXP_PORT, TENGHUA_XP_MASK, 0);
			/*_DBG("\r\t\t\t\tXM:");
			_DBD16(PIN_GetConf( TENGHUA_ADC_PREPARED_CHXM_PORT, TENGHUA_ADC_PREPARED_CHXM_PIN));
			_DBG("\r\t\t\t\t\t v:");
			_DBD(GPIO_ReadValue(TENGHUA_ADC_PREPARED_CHXM_PORT));
			*/
			ADC_IntConfig(LPC_ADC, TENGHUA_ADC_PREPARED_YM_INTR, ENABLE);
		
			
			break;
		}
		ADC_ChannelCmd(LPC_ADC, channel, ENABLE);


		switch(channel){
		case TENGHUA_ADC_PREPARED_XM_CHANNEL:
			
			channel = TENGHUA_ADC_PREPARED_YM_CHANNEL;
			break;
		case TENGHUA_ADC_PREPARED_XP_CHANNEL:
			channel = TENGHUA_ADC_PREPARED_YM_CHANNEL;
			break;
		case TENGHUA_ADC_PREPARED_YM_CHANNEL:
			channel = TENGHUA_ADC_PREPARED_XM_CHANNEL;
			break;
		case TENGHUA_ADC_PREPARED_YP_CHANNEL:
			channel=TENGHUA_ADC_PREPARED_XM_CHANNEL;
			
			break;
		}
		
	
		GPDMA_ChannelCmd(DMA_TP_CHANNEL, ENABLE);
		//ADC_GlobalSetChn(TENGHUA_ADC_PREPARED_XM_CHANNEL);
		ADC_StartCmd(LPC_ADC, ADC_START_NOW);

		/* Wait for GPDMA processing complete */
		while ((Channel_TP_TC == 0));

		// Disable GPDMA channel 0
		GPDMA_ChannelCmd(DMA_TP_CHANNEL, DISABLE);

		//Display the result of conversion on the UART
	
		//_DBG(ADC_GlobalGetChn(LPC_ADC)!=0?"\r\t\tY:":"\rX:");
		adc_value = ADC_DR_RESULT(adc_value);
		//_DBD16(adc_value); 
		
		if(ADC_GlobalGetChn(LPC_ADC)!=0){	//Y
#if 1
			//int y = 0;
			if(adc_value <=3270 && adc_value >= 1050){
				
				*y = (272-(adc_value - 1050)*272/2220);
				//rt_kprintf("y:%04d\n",*y);
				{
				 	struct rtgui_event_mouse emouse;
					emouse.wid = RT_NULL;
					RTGUI_EVENT_MOUSE_BUTTON_INIT(&emouse);
					emouse.button = (RTGUI_MOUSE_BUTTON_LEFT |RTGUI_MOUSE_BUTTON_DOWN);
					emouse.x = *x;
				    emouse.y = *y;
					rtgui_server_post_event(&emouse.parent, sizeof(struct rtgui_event_mouse));
					emouse.button = (RTGUI_MOUSE_BUTTON_LEFT |RTGUI_MOUSE_BUTTON_UP);
			
					rt_thread_delay(RT_TICK_PER_SECOND/10);
					rtgui_server_post_event(&emouse.parent, sizeof(struct rtgui_event_mouse)); 
				}
			} 
#else
			rt_kprintf("\ty:%04d\r",adc_value);
#endif
		}
		else{
#if 1
			//int x = 0;
			if(adc_value <=3700 && adc_value >= 570){
				*x = (480-(adc_value - 570)*480/3200);
				//rt_kprintf("x:%04d\n",*x);	
			} 
#else
			rt_kprintf("x:%04d\r",adc_value);
#endif
		}
		
		/* GPDMA Re-setup */
		GPDMA_Setup(&GPDMACfg);

		/* Reset terminal counter */
		Channel_TP_TC = 0;

		/* Reset Error counter */
		Channel_TP_Err = 0;
	}	
#endif
 	return;
}

void tp_init(void)
{
    
	ADC_Init(LPC_ADC, 400000);
	NVIC_DisableIRQ(DMA_IRQn);
#if ! MCI_DMA_ENABLED || (!defined(RT_USING_DFS) && !defined(	RT_USE_SDIO))
 	NVIC_SetPriority(DMA_IRQn, ((0x01<<3)|0x01));
	GPDMA_Init();
#endif
	// Setup GPDMA channel --------------------------------
	// channel 0
	GPDMACfg.ChannelNum = DMA_TP_CHANNEL;
	// Source memory - unused
	GPDMACfg.SrcMemAddr = 0;
	// Destination memory
	GPDMACfg.DstMemAddr = (uint32_t) &adc_value;
	// Transfer size
	GPDMACfg.TransferSize = DMA_SIZE;
	// Transfer width - unused
	GPDMACfg.TransferWidth = 0;
	// Transfer type
	GPDMACfg.TransferType = GPDMA_TRANSFERTYPE_P2M;
	// Source connection
	GPDMACfg.SrcConn = GPDMA_CONN_ADC;
	// Destination connection - unused
	GPDMACfg.DstConn = 0;
	// Linker List Item - unused
	GPDMACfg.DMALLI = 0;
	GPDMA_Setup(&GPDMACfg);

	/* Enable GPDMA interrupt */
	NVIC_EnableIRQ(DMA_IRQn);
}

void tp_entry(void * parameter)
{
	struct rtgui_event_mouse emouse;
	rt_thread_delay(RT_TICK_PER_SECOND*2);
	emouse.wid = RT_NULL;
	RTGUI_EVENT_MOUSE_BUTTON_INIT(&emouse);
	emouse.button = (RTGUI_MOUSE_BUTTON_LEFT |RTGUI_MOUSE_BUTTON_DOWN);
	while(1){
		int x=0,y=0;
		get_x_y(&x,&y);
		rt_kprintf("tp:x %d,y %d\n",x,y);
		emouse.x = x;
	    emouse.y = y;
		rtgui_server_post_event(&emouse.parent, sizeof(struct rtgui_event_mouse));
	 	rt_thread_delay(RT_TICK_PER_SECOND / 2);
	}
 	return;
}
